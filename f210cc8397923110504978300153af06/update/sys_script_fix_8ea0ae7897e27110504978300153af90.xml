<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_fix">
    <sys_script_fix action="INSERT_OR_UPDATE">
        <before>false</before>
        <description>Populating a new table from the Scoped table 'x_1092147_outage_l_outage_table_lv' by addressing the overlaping between Services issue&#13;
In this table we aggregating outages with the same 'Primary Impacted Service' field to one outage that starts at the earliest datetime of the outages and finishes and the latest datetime of them.</description>
        <name>Create Outage per Service table</name>
        <record_for_rollback>true</record_for_rollback>
        <script><![CDATA[// Define the original table name
var originalTableName = 'x_1092147_outage_l_outage_table_lv'; // Replace with your actual original table name

// Define the new table name
var newTableName = 'x_1092147_outage_l_outage_per_service_lv'; // Replace with your actual new table name
var oldtargetGr = new GlideRecord(newTableName);
oldtargetGr.query();
oldtargetGr.deleteMultiple();

var counter = 1;

// Create a GlideRecord to iterate through the records in the original table
var gr = new GlideRecord(originalTableName);
// gr.addEncodedQuery("beginON2023-01-01@javascript:gs.dateGenerate('2023-01-01','start')@javascript:gs.dateGenerate('2023-01-01','end')");
gr.query();

while (gr.next()) {	
    // Create a GlideRecord for the new table to store overlapping records
    var newRecordGr = new GlideRecord(newTableName);
    newRecordGr.initialize();

    // Create a GlideRecord to find overlapping records in the original table
    var overlappingGr = new GlideRecord(originalTableName);
    overlappingGr.addQuery('primary_impacted_service', gr.primary_impacted_service);
    overlappingGr.addQuery('sys_id', '!=', gr.sys_id);
    overlappingGr.addQuery('begin', '<=', gr.end); // It seems that this works however alter the dates to compare GlideDateTime Objects
    overlappingGr.addQuery('end', '>=', gr.begin);
    overlappingGr.query();

    // Check if there are overlapping records
    if (overlappingGr.hasNext()) {
        // Determine the start and end dates for the new record
        var newStartDate = new GlideDateTime(gr.begin);
        var newEndDate = new GlideDateTime(gr.end);
		
		var innerCounter = 1;
		
		while (overlappingGr.next()) {
			var overlapStartDate = new GlideDateTime(overlappingGr.begin);
			var overlapEndDate = new GlideDateTime(overlappingGr.end);
			
			if (overlapStartDate.before(newStartDate)) {
            newStartDate = overlapStartDate;
			}
			if (overlapEndDate.after(newEndDate)) {
            newEndDate = overlapEndDate;
			}
			
			// Log information about the overlapping record
            gs.info("[" + counter + "] [" + innerCounter + "] Processing Record: " + gr.number + ", Overlapping Record: " + overlappingGr.number + ", Start Date: " + overlappingGr.begin + ", End Date: " + overlappingGr.end + 
					" updating newStartDate: " + newStartDate + " and newEndDate: " + newEndDate);
			innerCounter++ ;

		}
		
		// Log information about the new record
        gs.info("Creating New Record for:" + gr.number + " with start Date: " + newStartDate + ", End Date: " + newEndDate);
		
        // Set the start and end dates for the new record
        newRecordGr.setValue('begin', newStartDate);
        newRecordGr.setValue('end', newEndDate);
        newRecordGr.setValue('primary_impacted_service', gr.primary_impacted_service);
		newRecordGr.setValue('number', gr.number); // delete this when you fix the issue

        // Optionally, set other fields as needed

        // Insert the new record into the new table
        newRecordGr.insert();
    } else {
		// If no overlapping records
		newRecordGr.setValue('begin', gr.begin);
		newRecordGr.setValue('end', gr.end);
		newRecordGr.setValue('primary_impacted_service', gr.primary_impacted_service);
		newRecordGr.setValue('configuration_item', gr.configuration_item);
		newRecordGr.setValue('number', gr.number);

		// Insert the new record into the new table
        newRecordGr.insert();
	}
	counter++;
}

// Update the duration field with newly calculated values
var ugr = new GlideRecord(newTableName);
ugr.query();

while(ugr.next()){
	var dt1 = new GlideDateTime(ugr.begin);
	var dt2 = new GlideDateTime(ugr.end);
	var duration = new GlideDateTime.subtract(dt1,dt2);
	ugr.setValue('duration', duration);
	
	// Insert the record into the new table
	ugr.update();
}

]]></script>
        <sys_class_name>sys_script_fix</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2023-11-14 10:31:18</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>8ea0ae7897e27110504978300153af90</sys_id>
        <sys_mod_count>73</sys_mod_count>
        <sys_name>Create Outage per Service table</sys_name>
        <sys_package display_value="Outage-LV" source="x_1092147_outage_l">f210cc8397923110504978300153af06</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Outage-LV">f210cc8397923110504978300153af06</sys_scope>
        <sys_update_name>sys_script_fix_8ea0ae7897e27110504978300153af90</sys_update_name>
        <sys_updated_by>VelentL</sys_updated_by>
        <sys_updated_on>2023-11-17 17:31:13</sys_updated_on>
        <unloadable>false</unloadable>
    </sys_script_fix>
</record_update>
